<html>

<head>
    <title>Level Editor</title>
    <link rel="stylesheet" type="text/css" href="../client/levelEditor.css" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" />
</head>

<body>
    <div>
        <!-- <div class="tab">
            <button class="tablinks active" id="defaultOpen" onclick="openTab(event,'scenery')">Scenery</button>
            <button class="tablinks" onclick="openTab(event,'platforms')">Platforms</button>
            <button class="tablinks" onclick="openTab(event,'enemies')">Enemies</button>
            <button class="tablinks" onclick="openTab(event,'powerups')">Power Ups</button>
            <button class="tablinks" onclick="openTab(event,'gameplayobjects')">Gameplay Objects</button>
        </div> -->
        <nav class="navbar navbar-expand-md bg-dark navbar-dark">
     <ul class="navbar-nav">
       <div class="tab">
           <button type="button" class="tablinks active" id="defaultOpen" onclick="openTab(event,'scenery')">
               Scenery
           </button>
       <div>
       <li class="val">
         <a class="nav-link" href="../client/gameMenu.html">
           <img src="../client/images/arrowBack.png" alt="Back arrow" width="30" height="30" />
           Back
         </a>
       </li>
     </ul>
   </nav>
        <div id="scenery" class="tabcontent">
            <select>
                <option value="castle">Castle</option>
                <option value="forest">Forest</option>
                <option value="underwater">Underwater</option>
                <option value="cave">Cave</option>
            </select>
            <!-- <input id="backgroundColor" type="color"> Background Colour -->
            <!-- <button id="applyColor">Apply Colour</button> -->
            <input id="levelName" type="text">Level Name
            <button id="save">Save</button>
            <br>
            <p>Left click and drag to place tiles, right click and drag to remove tiles.</p>
        </div>
        <div id="platforms" class="tabcontent">
            platforms
        </div>
        <div id="enemies" class="tabcontent">
            enemies
        </div>
        <div id="powerups" class="tabcontent">
            powerups
        </div>
        <div id="gameplayobjects" class="tabcontent">
            gameplay objects
        </div>
        <canvas id="myCanvas" width="1000" height="800"></canvas>
        <label id="result"></label>
        <label id="castleResult"></label>
        <label id="forestResult"></label>
        <label id="underwaterResult"></label>
        <label id="caveResult"></label>
    </div>
    <script src="https://cdn.socket.io/socket.io-1.4.5.js"></script>
    <script>

        var socket = io();

        let castleImage = new Image();
        castleImage.src = '../client/images/castle.png';
        let castlesw = 1920;
        let castlesh = 918;

        let forestImage = new Image();
        forestImage.src = '../client/images/forest.png';
        let forestsw = 700;
        let forestsh = 400;

        let underwaterImage = new Image();
        underwaterImage.src = '../client/images/lava.png';
        let underwatersw = 720;
        let underwatersh = 320;

        let caveImage = new Image();
        caveImage.src = '../client/images/cave.png';
        let cavesw = 1000;
        let cavesh = 500;

        let tilemapImage = new Image();
        tilemapImage.src = '../client/images/tilemap.png';
        let tilemapsw = 416;
        let tilemapsh = 32;

        let sourceWidth = tilemapsw,
            sourceHeight = tilemapsh;
        let image = new Image();
        image.src = tilemapImage.src;

        let backgroundImage = castleImage.src;
        let bgiSw = castlesw;
        let bgiSh = castlesh;
        //tabs

        document.getElementById("defaultOpen").click();

        var incorporateTiles = function (oldTiles, newTiles) {
            for (let i = 0; i < mapRows; i++) {
                for (let j = 0; j < mapColumns; j++) {
                    // if (newTiles[i][j] != undefined) {
                        oldTiles[i][j] = newTiles[i][j];
                    // }
                }
            }
        }

        changeBackgroundImage(castlesw, castlesh, castleImage.src);

        sceneryOptions = document.getElementsByTagName("select")[0];
        let sceneryIndex = sceneryOptions.selectedIndex;
        sceneryOptions.onchange = function () {
            sceneryIndex = sceneryOptions.selectedIndex;
            if (sceneryOptions.selectedIndex == 0) {
                changeBackgroundImage(castlesw, castlesh, castleImage.src);
                // changeImage(512, 512, '../client/images/castleTiles.png');
                incorporateTiles(castleTiles, tiles);
                tiles = refreshTiles();
                backgroundImage = castleImage.src;
                bgiSw = castlesw;
                bgiSh = castlesh;
            }
            else if (sceneryOptions.selectedIndex == 1) {
                changeBackgroundImage(forestsw, forestsh, forestImage.src);
                // changeImage(256, 608, '../client/images/dark_forest.png');
                incorporateTiles(forestTiles, tiles);
                tiles = refreshTiles();
                backgroundImage = forestImage.src;
                bgiSw = forestsw;
                bgiSh = forestsh;
            }
            else if (sceneryOptions.selectedIndex == 2) {
                changeBackgroundImage(underwatersw, underwatersh, underwaterImage.src);
                // changeImage(512, 512, '../client/images/underwater.png');
                incorporateTiles(underwaterTiles, tiles);
                tiles = refreshTiles();
                backgroundImage = underwaterImage.src;
                bgiSw = underwatersw;
                bgiSh = underwatersh;
            }
            else if (sceneryOptions.selectedIndex == 3) {
                changeBackgroundImage(cavesw, cavesh, caveImage.src);
                // changeImage(256, 336, '../client/images/cave_tileset.png');
                incorporateTiles(caveTiles, tiles);
                tiles = refreshTiles();
                backgroundImage = caveImage.src;
                bgiSw = cavesw;
                bgiSh = cavesh;
            }
        }

        function changeImage(sw, sh, imageSrc) {
            image.src = imageSrc;
            context.clearRect(0, mapHeight, sourceWidth, sourceHeight);
            sourceWidth = sw;
            sourceHeight = sh;
            redrawSource();
        }

        function changeBackgroundImage(sw, sh, imageSrc) {
            let i = new Image();
            i.src = imageSrc;
            i.onload = function () {
                context.clearRect(0, 0, mapWidth, mapHeight);
                context.drawImage(i, 0, 0, sw, sh, 0, 0, mapWidth, mapHeight);
                drawGrid();
                loadTiles(tiles, 416, "../client/images/tilemap.png");
            }
        }

        function openTab(evt, tabName) {
            var i, tabcontent, tablinks;

            tabcontent = document.getElementsByClassName("tabcontent");
            for (i = 0; i < tabcontent.length; i++) {
                tabcontent[i].style.display = "none";
            }

            tablinks = document.getElementsByClassName("tablinks");
            for (i = 0; i < tablinks.length; i++) {
                tablinks[i].className = tablinks[i].className.replace(" active", "");
            }

            document.getElementById(tabName).style.display = "block";
            evt.currentTarget.className += " active";

        }

        const tileWidth = 32,
            tileHeight = 32;
        const mapRows = 8,
            mapColumns = 80;

        var refreshTiles = function () {
            let tiles = new Array(mapRows);

            for (i = 0; i < mapRows; i++) {
                tiles[i] = new Array(mapColumns);
            }
            return tiles;
        }

        let tiles = refreshTiles();
        let realTiles = refreshTiles();
        let castleTiles = refreshTiles();
        let forestTiles = refreshTiles();
        let underwaterTiles = refreshTiles();
        let caveTiles = refreshTiles();

        document.getElementById("save").onclick = function () {
            socket.emit('saveLevel', {
                user: sessionStorage.getItem("username"),
                name: document.getElementById("levelName").value,
                castleArray: castleTiles,
                forestArray: forestTiles,
                underwaterArray: underwaterTiles,
                caveArray: caveTiles,
                background: bgColor,
                backgroundImage: backgroundImage,
                bgiSw: bgiSw,
                bgiSh: bgiSh,
                realArray: tiles
            });
        };
        socket.on('saveLevelResponse', function (data) {
            if (data.success) {
                alert('Save successful.');
            } else alert('Save unsuccessful.');
        });


        let mapHeight = mapRows * tileHeight;
        let mapWidth = mapColumns * tileWidth;
        let topOffset = document.getElementById("myCanvas").offsetTop;
        let sourceX, sourceY, sourceTile;
        let holder = document.getElementById("result");
        let canvas = document.getElementById('myCanvas');
        let context = canvas.getContext('2d');
        let mouseDown;
        canvas.addEventListener('mousedown', doMouseDown);
        document.addEventListener('contextmenu', event => event.preventDefault());
        canvas.addEventListener('click', doMouseClick);
        canvas.addEventListener('mousemove', doMouseMove);
        canvas.addEventListener('mouseup', doMouseUp);
        image.addEventListener('load', redrawSource);

        // draw the grid
        var drawGrid = function () {
            context.strokeStyle = "black";
            for (let i = 0; i <= mapColumns; i++) {
                context.moveTo(i * tileWidth, 0);
                context.lineTo(i * tileWidth, mapHeight);
            }
            context.stroke();
            for (let i = 0; i <= mapRows; i++) {
                context.moveTo(0, i * tileHeight);
                context.lineTo(mapWidth, i * tileHeight);
            }
            context.stroke();
        }

        drawGrid();

        var colorPicker = document.getElementById("backgroundColor");
        var applyColor = document.getElementById("applyColor");
        var bgColor = "#ffffff";

        applyColor.onclick = function () {
            bgColor = colorPicker.value;
            context.fillStyle = colorPicker.value;
            context.fillRect(0, 0, mapWidth, mapHeight);
            drawGrid();
            loadTiles(tiles, 416, "../client/images/tilemap.png");
            // loadTiles(castleTiles, 512, "../client/images/castleTiles.png");
            // loadTiles(forestTiles, 256, "../client/images/dark_forest.png");
            // loadTiles(underwaterTiles, 512, "../client/images/underwater.png");
            // loadTiles(caveTiles, 256, "../client/images/cave_tileset.png");
        }

        function loadTiles(tileArray, srcWidth, img) {
            let image = new Image();
            image.src = img;
            image.onload = function () {
                for (var i = 0; i < mapRows; i++) {
                    for (var j = 0; j < mapColumns; j++) {
                        if (tileArray[i][j] != undefined && tileArray[i][j] !== null) {
                            let tileY = Math.floor(tileArray[i][j] / (srcWidth / tileWidth)) * tileHeight;
                            let tileX = tileArray[i][j] * tileWidth;
                            if (tileY != 0) {
                                tileX = (tileArray[i][j] - (Math.floor(tileArray[i][j] / (srcWidth / tileWidth)) * (srcWidth / tileWidth))) * tileWidth;
                            }
                            let gridi = i * tileWidth;
                            let gridj = j * tileHeight;
                            context.drawImage(image, tileX, tileY, tileWidth, tileHeight, gridj, gridi, tileWidth, tileHeight);
                        }
                    }
                }
            }
        }


        function redrawSource() {
            context.drawImage(image, 0, 0, sourceWidth, sourceHeight, 0, mapHeight, sourceWidth, sourceHeight);
        }


        function doMouseUp(e){
            mouseDown = false;
        }

        function doMouseClick(e) {

            let x = e.clientX;
            let y = e.clientY + pageYOffset - topOffset;
            let gridX = Math.floor(x / tileWidth) * tileWidth;
            let gridY = Math.floor(y / tileHeight) * tileHeight;

            if (y > mapHeight && y < (mapHeight + sourceHeight) && x < sourceWidth) { // source
                let tileX = Math.floor(x / tileWidth);
                let tileY = Math.floor((y - mapHeight) / tileHeight);
                sourceTile = tileY * (sourceWidth / tileWidth) + tileX;
                sourceX = gridX;
                sourceY = gridY - mapHeight;
                redrawSource();
                drawBox();
            }

            drawTile(e);
        }

        var updateString = function (holder, tileArray) {
            let string = 'let tiles = [';
            for (let i = 0; i < mapRows; i++) {
                for (let j = 0; j < mapColumns; j++) {
                    if (tileArray[i][j] != undefined && tileArray[i][j] !== null) string = string + tileArray[i][j];
                    string = string + ',';
                }
            }
            string = string + '];';
            holder.innerHTML = string;
        }

        function doMouseDown(e){
            mouseDown = true;
            let x = e.clientX;
            let y = e.clientY + pageYOffset - topOffset;
            let gridX = Math.floor(x / tileWidth) * tileWidth;
            let gridY = Math.floor(y / tileHeight) * tileHeight;

            if (y > mapHeight && y < (mapHeight + sourceHeight) && x < sourceWidth) { // source
                let tileX = Math.floor(x / tileWidth);
                let tileY = Math.floor((y - mapHeight) / tileHeight);
                sourceTile = tileY * (sourceWidth / tileWidth) + tileX;
                sourceX = gridX;
                sourceY = gridY - mapHeight;
                redrawSource();
                drawBox();
            }
        }

        function doMouseMove(e) {
            let x = e.clientX;
            let y = e.clientY + pageYOffset - topOffset;

            if (y > mapHeight && y < (mapHeight + sourceHeight) && x < sourceWidth) { // source
                let gridX = Math.floor(x / tileWidth) * tileWidth;
                let gridY = Math.floor(y / tileHeight) * tileHeight;
                context.clearRect(0, mapHeight, sourceWidth, sourceHeight);
                redrawSource();
                context.beginPath();
                context.strokeStyle = 'blue';
                context.rect(gridX, gridY, tileWidth, tileHeight);
                context.stroke();
                drawBox();
            }

            if (mouseDown == true){
                drawTile(e);
            }
        }

        function drawTile(e) {
                let x = e.clientX;
                let y = e.clientY + pageYOffset - topOffset;
                let gridX = Math.floor(x / tileWidth) * tileWidth;
                let gridY = Math.floor(y / tileHeight) * tileHeight;
                if (y < mapHeight && x < mapWidth) { // target
                    // context.clearRect(gridX, gridY, tileWidth, tileHeight);
                    context.drawImage(image, sourceX, sourceY, tileWidth, tileHeight, gridX, gridY, tileWidth, tileHeight);
                    let tileX = Math.floor(x / tileWidth);
                    let tileY = Math.floor(y / tileHeight);
                    let targetTile = tileY * mapColumns + tileX;
                    tiles[tileY][tileX] = sourceTile;
                    if (e.buttons == 2) {
                        context.clearRect(gridX, gridY, tileWidth, tileHeight);
                        context.beginPath();
                        context.strokeStyle = 'black';
                        context.rect(gridX, gridY, tileWidth, tileHeight);
                        context.stroke();
                        tiles[tileY][tileX] = null;
                        changeBackgroundImage(bgiSw, bgiSh, backgroundImage);
                        
                    };
                }
            }

        function drawBox() {
            context.beginPath();
            context.strokeStyle = 'red';
            context.rect(sourceX, sourceY + mapHeight, tileWidth, tileHeight);
            context.stroke();
        }


        //level object
        var level = {
            castleArray: castleTiles,
            forestArray: forestTiles,
            underwaterArray: underwaterTiles,
            caveArray: caveTiles,
            background: bgColor
        };
    </script>
</body>

</html>