<html>

<head>
    <title>Level Editor</title>
    <link rel="stylesheet" type="text/css" href="../client/levelEditor.css" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
</head>

<body>
    <div>
        <div class="tab">
            <button class="tablinks active" id="defaultOpen" onclick="openTab(event,'scenery')">Scenery</button>
            <button class="tablinks" onclick="openTab(event,'platforms')">Platforms</button>
            <button class="tablinks" onclick="openTab(event,'enemies')">Enemies</button>
            <button class="tablinks" onclick="openTab(event,'powerups')">Power Ups</button>
            <button class="tablinks" onclick="openTab(event,'gameplayobjects')">Gameplay Objects</button>
        </div>
        <div id="scenery" class="tabcontent">
            <select>
                <option value="castle">Castle</option>
                <option value="forest">Forest</option>
                <option value="underwater">Underwater</option>
                <option value="cave">Cave</option>
            </select>
            <input id="backgroundColor" type="color"> Background Colour
            <button id="applyColor">Apply Colour</button>
            <input id="levelName" type="text">Level Name
            <button id="save">Save</button>
        </div>
        <div id="platforms" class="tabcontent">
            platforms
        </div>
        <div id="enemies" class="tabcontent">
            enemies
        </div>
        <div id="powerups" class="tabcontent">
            powerups
        </div>
        <div id="gameplayobjects" class="tabcontent">
            gameplay objects
        </div>
        <canvas id="myCanvas" width="1000" height="800"></canvas>
        <label id="result"></label>
        <label id="castleResult"></label>
        <label id="forestResult"></label>
        <label id="underwaterResult"></label>
        <label id="caveResult"></label>
    </div>
    <script src="https://cdn.socket.io/socket.io-1.4.5.js"></script>
    <script>

        var socket = io();

        let sourceWidth = 512,
            sourceHeight = 512;
        let image = new Image();
        image.src = '../client/images/castleTiles.png';


        //tabs

        document.getElementById("defaultOpen").click();

        var incorporateTiles = function (oldTiles, newTiles) {
            for (let i = 0; i < mapRows; i++) {
                for (let j = 0; j < mapColumns; j++) {
                    if (newTiles[i][j] != undefined) {
                        oldTiles[i][j] = newTiles[i][j];
                    }
                }
            }
        }

        sceneryOptions = document.getElementsByTagName("select")[0];
        let sceneryIndex = sceneryOptions.selectedIndex;
        sceneryOptions.onclick = function () {
            sceneryIndex = sceneryOptions.selectedIndex;
            if (sceneryOptions.selectedIndex == 0) {
                changeImage(512, 512, '../client/images/castleTiles.png');
                incorporateTiles(castleTiles, tiles);
                tiles = refreshTiles();
            }
            else if (sceneryOptions.selectedIndex == 1) {
                changeImage(256, 608, '../client/images/dark_forest.png');
                incorporateTiles(forestTiles, tiles);
                tiles = refreshTiles();
            }
            else if (sceneryOptions.selectedIndex == 2) {
                changeImage(512, 512, '../client/images/underwater.png');
                incorporateTiles(underwaterTiles, tiles);
                tiles = refreshTiles();
            }
            else if (sceneryOptions.selectedIndex == 3) {
                changeImage(256, 336, '../client/images/cave_tileset.png');
                incorporateTiles(caveTiles, tiles);
                tiles = refreshTiles();
            }
        }

        function changeImage(sw, sh, imageSrc) {
            image.src = imageSrc;
            context.clearRect(0, mapHeight, sourceWidth, sourceHeight);
            sourceWidth = sw;
            sourceHeight = sh;
            redrawSource();
        }

        function openTab(evt, tabName) {
            var i, tabcontent, tablinks;

            tabcontent = document.getElementsByClassName("tabcontent");
            for (i = 0; i < tabcontent.length; i++) {
                tabcontent[i].style.display = "none";
            }

            tablinks = document.getElementsByClassName("tablinks");
            for (i = 0; i < tablinks.length; i++) {
                tablinks[i].className = tablinks[i].className.replace(" active", "");
            }

            document.getElementById(tabName).style.display = "block";
            evt.currentTarget.className += " active";

        }

        const tileWidth = 32,
            tileHeight = 32;
        const mapRows = 8,
            mapColumns = 80;

        var refreshTiles = function () {
            let tiles = new Array(mapRows);

            for (i = 0; i < mapRows; i++) {
                tiles[i] = new Array(mapColumns);
            }
            return tiles;
        }

        let tiles = refreshTiles();
        let castleTiles = refreshTiles();
        let forestTiles = refreshTiles();
        let underwaterTiles = refreshTiles();
        let caveTiles = refreshTiles();

        document.getElementById("save").onclick = function () {
            socket.emit('saveLevel', {
                user: sessionStorage.getItem("username"),
                name: document.getElementById("levelName").value,
                castleArray: castleTiles,
                forestArray: forestTiles,
                underwaterArray: underwaterTiles,
                caveArray: caveTiles,
                background: bgColor
            });
        };
        socket.on('saveLevelResponse', function (data) {
            if (data.success) {
                alert('Save successful.');
            } else alert('Save unsuccessful.');
        });


        let mapHeight = mapRows * tileHeight;
        let mapWidth = mapColumns * tileWidth;
        let topOffset = document.getElementById("myCanvas").offsetTop;
        let sourceX, sourceY, sourceTile;
        let canvas = document.getElementById('myCanvas');
        let context = canvas.getContext('2d');
        canvas.addEventListener('click', doMouseClick);
        canvas.addEventListener('mousemove', doMouseMove);
        image.addEventListener('load', redrawSource);

        // draw the grid
        var drawGrid = function () {
            context.strokeStyle = "black";
            for (let i = 0; i <= mapColumns; i++) {
                context.moveTo(i * tileWidth, 0);
                context.lineTo(i * tileWidth, mapHeight);
            }
            context.stroke();
            for (let i = 0; i <= mapRows; i++) {
                context.moveTo(0, i * tileHeight);
                context.lineTo(mapWidth, i * tileHeight);
            }
            context.stroke();
        }

        drawGrid();

        var colorPicker = document.getElementById("backgroundColor");
        var applyColor = document.getElementById("applyColor");
        var bgColor = "#ffffff";

        applyColor.onclick = function () {
            bgColor = colorPicker.value;
            context.fillStyle = colorPicker.value;
            context.fillRect(0, 0, mapWidth, mapHeight);
            drawGrid();
            loadTiles(castleTiles, 512, "../client/images/castleTiles.png");
            loadTiles(forestTiles, 256, "../client/images/dark_forest.png");
            loadTiles(underwaterTiles, 512, "../client/images/underwater.png");
            loadTiles(caveTiles, 256, "../client/images/cave_tileset.png");
        }

        function loadTiles(tileArray, srcWidth, img) {
            let image = new Image();
            image.src = img;
            image.onload = function () {
                for (var i = 0; i < mapRows; i++) {
                    for (var j = 0; j < mapColumns; j++) {
                        if (tileArray[i][j] != undefined) {
                            let tileY = Math.floor(tileArray[i][j] / (srcWidth / tileWidth)) * tileHeight;
                            let tileX = tileArray[i][j] * tileWidth;
                            if (tileY != 0) {
                                tileX = (tileArray[i][j] - (Math.floor(tileArray[i][j] / (srcWidth / tileWidth)) * (srcWidth / tileWidth))) * tileWidth;
                            }
                            let gridi = i * tileWidth;
                            let gridj = j * tileHeight;
                            context.drawImage(image, tileX, tileY, tileWidth, tileHeight, gridj, gridi, tileWidth, tileHeight);
                        }
                    }
                }
            }
        }


        function redrawSource() {
            context.drawImage(image, 0, 0, sourceWidth, sourceHeight, 0, mapHeight, sourceWidth, sourceHeight);
        }

        function doMouseClick(e) {

            let x = e.clientX;
            let y = e.clientY + pageYOffset - topOffset;
            let gridX = Math.floor(x / tileWidth) * tileWidth;
            let gridY = Math.floor(y / tileHeight) * tileHeight;

            if (y > mapHeight && y < (mapHeight + sourceHeight) && x < sourceWidth) { // source
                let tileX = Math.floor(x / tileWidth);
                let tileY = Math.floor((y - mapHeight) / tileHeight);
                sourceTile = tileY * (sourceWidth / tileWidth) + tileX;
                sourceX = gridX;
                sourceY = gridY - mapHeight;
                redrawSource();
                drawBox();
            }

            if (y < mapHeight && x < mapWidth) { // target
                // context.clearRect(gridX, gridY, tileWidth, tileHeight);
                context.drawImage(image, sourceX, sourceY, tileWidth, tileHeight, gridX, gridY, tileWidth, tileHeight);
                let tileX = Math.floor(x / tileWidth);
                let tileY = Math.floor(y / tileHeight);
                let targetTile = tileY * mapColumns + tileX;
                tiles[tileY][tileX] = sourceTile;

                if (sceneryOptions.selectedIndex == 0) {
                    incorporateTiles(castleTiles, tiles);
                }
                else if (sceneryOptions.selectedIndex == 1) {
                    incorporateTiles(forestTiles, tiles);
                }
                else if (sceneryOptions.selectedIndex == 2) {
                    incorporateTiles(underwaterTiles, tiles);
                }
                else if (sceneryOptions.selectedIndex == 3) {
                    incorporateTiles(caveTiles, tiles);
                }

                // update the string    
                updateString(document.getElementById("result"), tiles);
                updateString(document.getElementById("castleResult"), castleTiles);
                updateString(document.getElementById("forestResult"), forestTiles);
                updateString(document.getElementById("underwaterResult"), underwaterTiles);
                updateString(document.getElementById("caveResult"), caveTiles);

            }
        }

        var updateString = function (holder, tileArray) {
            let string = 'let tiles = [';
            for (let i = 0; i < mapRows; i++) {
                for (let j = 0; j < mapColumns; j++) {
                    if (tileArray[i][j] != undefined) string = string + tileArray[i][j];
                    string = string + ',';
                }
            }
            string = string + '];';
            holder.innerHTML = string;
        }

        function doMouseMove(e) {
            let x = e.clientX;
            let y = e.clientY + pageYOffset - topOffset;

            if (y > mapHeight && y < (mapHeight + sourceHeight) && x < sourceWidth) { // source
                let gridX = Math.floor(x / tileWidth) * tileWidth;
                let gridY = Math.floor(y / tileHeight) * tileHeight;
                context.clearRect(0, mapHeight, sourceWidth, sourceHeight);
                redrawSource();
                context.beginPath();
                context.strokeStyle = 'blue';
                context.rect(gridX, gridY, tileWidth, tileHeight);
                context.stroke();
                drawBox();
            }
        }

        function drawBox() {
            context.beginPath();
            context.strokeStyle = 'red';
            context.rect(sourceX, sourceY + mapHeight, tileWidth, tileHeight);
            context.stroke();
        }


        //level object
        var level = {
            castleArray: castleTiles,
            forestArray: forestTiles,
            underwaterArray: underwaterTiles,
            caveArray: caveTiles,
            background: bgColor
        };
    </script>
</body>

</html>